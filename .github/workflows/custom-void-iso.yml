name: Build Void Live ISO (bypass mkiso.sh)

on:
  workflow_dispatch:
    inputs:
      arch:
        description: "目标架构 (x86_64 / x86_64-musl / aarch64 …)"
        default: "x86_64"
        required: true
        type: string
      datecode:
        description: "日期码 (YYYYMMDD, 默认为今天 UTC)"
        required: false
        type: string
      extra_packages:
        description: "自选额外包 (空格分隔，可留空)"
        default: "xfce4 xfce4-terminal network-manager-applet dbus-elogind"
        required: false
        type: string
      extra_services:
        description: "自选要启用的 runit 服务 (空格分隔，可留空)"
        default: ""
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout 你 fork 的 void-mklive 仓库（包含 mklive.sh）
      - uses: actions/checkout@v4

      # 2) Build 一个 Ubuntu 容器，安装 mklive 所需所有宿主工具
      - name: Build builder image
        run: |
          cat > Dockerfile << 'EOF'
          FROM ubuntu:22.04
          ENV DEBIAN_FRONTEND=noninteractive

          # 安装 mklive.sh 生成 ISO 需要的所有 Linux 工具
          RUN apt-get update && \
              apt-get install -y --no-install-recommends \
                ca-certificates \
                curl \
                git \
                xz-utils \
                lzop \
                dosfstools \
                e2fsprogs \
                squashfs-tools \
                kmod \
                util-linux \
                genisoimage \
                mtools \
                make \
                dracut && \
              rm -rf /var/lib/apt/lists/*

          # 下载 xbps-static，以便 mklive.sh 在构建过程中可以用 xbps-install 拉取 Void 二进制包
          RUN curl -LO https://repo-default.voidlinux.org/static/xbps-static-latest.x86_64-musl.tar.xz && \
              mkdir -p /opt/xbps && \
              tar -xf xbps-static-latest.x86_64-musl.tar.xz -C /opt/xbps && \
              chmod -R a+rx /opt/xbps

          ENV PATH=/opt/xbps/usr/bin:$PATH
          EOF

          docker build -t void-mklive-builder - < Dockerfile

      # 3) 在容器中直接调用 mklive.sh，手动拼包与服务
      - name: Build ISO via mklive.sh
        run: |
          set -e
          # 计算日期码：如果用户留空，则取今天 UTC(YYYYMMDD)
          if [ -z "${{ inputs.datecode }}" ]; then
            DATECODE=$(date -u +%Y%m%d)
          else
            DATECODE=${{ inputs.datecode }}
          fi

          ARCH="${{ inputs.arch }}"
          EXTRA_PKGS="${{ inputs.extra_packages }}"
          EXTRA_SVCS="${{ inputs.extra_services }}"

          docker run --rm --privileged \
            -e DATECODE="$DATECODE" \
            -e ARCH="$ARCH" \
            -e EXTRA_PKGS="$EXTRA_PKGS" \
            -e EXTRA_SVCS="$EXTRA_SVCS" \
            -v "$PWD":/workspace \
            -w /workspace \
            void-mklive-builder \
            bash -euxo pipefail -c '
              # （1）make 一下，确保 mklive.sh 是最新的
              make

              # （2）构建传给 mklive.sh 的完整包列表字符串：
              #     【必须】把 squashfs-tools kmod 放最前面，保证会安装到 void-host/usr/bin/mksquashfs
              PKG_STR="squashfs-tools kmod base-system"
              #    base-system 是最小系统（含 glibc、核心库、runit、xbps…
              #    你可以根据需求把 “xfce” 等桌面环境一起放到 PKG_STR 里
              #    下面拼接用户在 UI 填写的 EXTRA_PKGS
              if [ -n "$EXTRA_PKGS" ]; then
                PKG_STR="$PKG_STR $EXTRA_PKGS"
              fi

              # （3）如果 EXTRA_SVCS 不为空，就把它作为一个整体字符串给 -S
              SVC_ARG=""
              if [ -n "$EXTRA_SVCS" ]; then
                SVC_ARG="-S \"$EXTRA_SVCS\""
              fi

              # （4）调用 mklive.sh：架构、仓库、包与服务列表都传进去
              #     最终会输出 void-<arch>-<datecode>.iso
              eval "./mklive.sh \
                -a \"$ARCH\" \
                -r https://repo-default.voidlinux.org/current \
                -p \"$PKG_STR\" \
                $SVC_ARG \
                -o void-$ARCH-$DATECODE.iso"
            '

      # 4) 上传生成的 ISO
      - uses: actions/upload-artifact@v4
        with:
          name: void-${{ inputs.arch }}-iso
          path: void-*.iso
