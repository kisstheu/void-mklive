name: Custom Void ISO (using mkiso.sh)

on:
  workflow_dispatch:
    inputs:
      arch:
        description: "目标架构 (x86_64 / x86_64-musl …)"
        default: "x86_64"
        required: true
        type: string
      datecode:
        description: "可选日期码 (默认为今天 UTC)"
        required: false
        type: string
      flavor:
        description: "预置 Live ISO flavor (base/xfce/…)"
        default: "xfce"
        required: true
        type: string
      extra_packages:
        description: "额外要安装的包 (空格分隔，可留空)"
        default: ""
        required: false
        type: string
      extra_services:
        description: "要启用的 runit 服务 (空格分隔，可留空)"
        default: ""
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # 1) 拉取你 fork 的 void-mklive 源码
      - uses: actions/checkout@v4

      # 2) 构建一个 Ubuntu 容器做宿主环境（包含运行 mkiso.sh 必要的工具）
      - name: Build builder image
        run: |
          cat > Dockerfile <<'EOF'
          FROM ubuntu:22.04
          ENV DEBIAN_FRONTEND=noninteractive

          RUN apt-get update && \
              apt-get install -y --no-install-recommends \
                  ca-certificates curl git xz-utils lzop dosfstools e2fsprogs \
                  squashfs-tools kmod util-linux genisoimage mtools make dracut && \
              rm -rf /var/lib/apt/lists/*

          # xbps-static (musl) for xbps-install inside container
          RUN curl -LO https://repo-default.voidlinux.org/static/xbps-static-latest.x86_64-musl.tar.xz && \
              mkdir -p /opt/xbps && \
              tar -xf xbps-static-latest.x86_64-musl.tar.xz -C /opt/xbps && \
              chmod -R a+rx /opt/xbps

          ENV PATH=/opt/xbps/usr/bin:$PATH
          EOF

          docker build -t my-void-builder - < Dockerfile

      # 3) 在容器里调用 mkiso.sh：通过 “--” 把 -p/-S 选项连同 “squashfs-tools kmod” 一起传给 mklive.sh
      - name: Build ISO with mkiso.sh
        run: |
          set -e
          # 计算日期码：如果没有输入，就用今天 UTC
          if [ -z "${{ inputs.datecode }}" ]; then
            DATECODE=$(date -u +%Y%m%d)
          else
            DATECODE=${{ inputs.datecode }}
          fi

          ARCH="${{ inputs.arch }}"
          FLAVOR="${{ inputs.flavor }}"
          EXTRA_PKGS="${{ inputs.extra_packages }}"
          EXTRA_SVCS="${{ inputs.extra_services }}"

          docker run --rm --privileged \
            -e DATECODE="$DATECODE" \
            -e ARCH="$ARCH" \
            -e FLAVOR="$FLAVOR" \
            -e EXTRA_PKGS="$EXTRA_PKGS" \
            -e EXTRA_SVCS="$EXTRA_SVCS" \
            -v "$PWD":/workspace \
            -w /workspace \
            my-void-builder \
            bash -euxo pipefail -c '
              # 确保 mkiso.sh 使用的是最新源码
              make

              # 构建要传给 mklive.sh 的完整包列表（字符串），必须把 squashfs-tools 与 kmod 放最前
              PKG_STR="squashfs-tools kmod"
              if [ -n "$EXTRA_PKGS" ]; then
                PKG_STR="$PKG_STR $EXTRA_PKGS"
              fi

              # 构建要传给 mklive.sh 的服务列表（字符串）
              if [ -n "$EXTRA_SVCS" ]; then
                SVC_STR="$EXTRA_SVCS"
              else
                SVC_STR=""
              fi

              # 组装 mkiso.sh 参数数组
              ARGS=( "./mkiso.sh" "-a" "$ARCH" "-b" "$FLAVOR" "-d" "$DATECODE" "-r" "https://repo-default.voidlinux.org/current" "--" )

              # 把单个字符串 PKG_STR 作为一个整体参数给 -p
              ARGS+=( "-p" "$PKG_STR" )

              # 如果有服务要启用，就把 SVC_STR 作为一个整体参数给 -S
              if [ -n "$SVC_STR" ]; then
                ARGS+=( "-S" "$SVC_STR" )
              fi

              # 执行 mkiso.sh（输出为 void-<arch>-<flavor>-<date>.iso）
              "${ARGS[@]}"
            '

      # 4) 上传生成的 ISO
      - uses: actions/upload-artifact@v4
        with:
          name: void-${{ inputs.arch }}-${{ inputs.flavor }}-iso
          path: void-*-*-*.iso
